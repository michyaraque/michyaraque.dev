---
title: '¿Por qué deberías hacer Test sobre el funcionamiento en el futuro de tu Smart Contract?'
publishedAt: '20/05/2022'
summary: 'Test summary'
---

Me he dado cuenta que muchos desarrolladores, en sus etapas más tempranas, suelen dejar de lado los tests. No probar el código de manera correcta puede llegar a ser catastrófico, y más cuando hablamos de Smart Contracts donde la normalidad es que intervenga el *'dinerito'*... Dudo que a alguien le guste perder *'dinerito'* ¿o sí? La cosa está que en caso de ocurrir un error no se perderían *2 eurillos* sueltos, se pueden llegar a perder cantidades gigantescas de dinero por no haber hecho buen uso de las herramientas de testing.

Es por esto que te voy a compartir una manera rápida y sencilla de poder testear como va a interactuar tu smart contract en el futuro. Las pruebas del futuro son necesarias en contratos de tipo *'Vesting'* o de tipo *'Crowd'*.

Pongamos el siguiente ejemplo donde crearemos un contrato llamado **TestFuture** que nos servirá de guía para saber que realmente sí estamos adelantando el tiempo.

> Creamos el smart contract de pruebas

```solidity
pragma 0.8.4;

contract TestFuture {

    const internal _MIN_DELAY = 120;
    mapping(address => uint) private trackTime;

    function execute(address addr) public returns(boolean) {
        require(trackTime[addr] >= block.timestamp, "GUARD: Wait for the time");
        trackTime[addr] = block.timestamp + _MIN_DELAY;
        return true;
    }
}
```

### Ahora testeemos el futuro con Chai +  Waffle

```js
describe("Token contract", async () => {

  let testFuture: Contract;

  before(async () => {
    [test, ...addrs] = await ethers.getSigners();

    const TestFuture = await ethers.getContractFactory("TestFuture");
    testFuture = await TestFuture.deployed()
  });

  ///////
  it("Test the future", async() => {
    await testFuture.execute(test.address);
  });

  it("Debería revertir el proceso", async() => {
    await expect(testFuture.execute(test.address))
          .to.be.revertedWith('GUARD: Wait for the time');
  })

  it("Test the future", async() => {
    // Adelantemos el tiempo
    await AdvanceTime(121);
    // Se ejecutará ya que el timestamp actual es superior al del trackTime
    await testFuture.execute(test.address);
  });
  //////
});
```
